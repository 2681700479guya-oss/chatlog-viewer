<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChatGPT èŠå¤©è®°å½•æŸ¥çœ‹å™¨</title>
<style>
:root{
  --bg-light:#f6f6f7; --bg-dark:#1b1b1f;
  --text-light:#0f1115; --text-dark:#e7e7ea;
  --user:#0a84ff; --assistant:#5e5e66; --sys:#9b59b6;
  --chip:#d0d5dd22; --border:#00000014; --border-dark:#ffffff22;
  --bubble-max:86%;
}
*{box-sizing:border-box}
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;background:var(--bg-light);color:var(--text-light);transition:.25s}
body.dark{background:var(--bg-dark);color:var(--text-dark)}

/* é¡¶æ  */
header{position:sticky;top:0;z-index:20;backdrop-filter:saturate(180%) blur(8px);
  background:color-mix(in oklab,currentColor 6%,transparent);
  display:flex;gap:.6rem;align-items:center;justify-content:space-between;
  padding:.6rem .9rem;border-bottom:1px solid var(--border)}
body.dark header{border-bottom-color:var(--border-dark)}
h1{font-size:1rem;margin:0;font-weight:600;display:flex;gap:.5rem;align-items:center}
.controls{display:flex;gap:.4rem;flex-wrap:wrap;align-items:center;justify-content:flex-end}
button,select,input[type="number"],input[type="range"]{
  padding:.45rem .7rem;border-radius:9px;border:1px solid var(--border);
  background:#fff;color:#111;cursor:pointer;font-size:.9rem
}
body.dark button,body.dark select,body.dark input[type="number"],body.dark input[type="range"]{
  background:#2a2a31;color:var(--text-dark);border-color:var(--border-dark)
}
button:active{transform:scale(.98)}
input[type=file]{display:none}
.icon{font-size:1.1rem}

/* å¸ƒå±€ï¼šä¾§è¾¹æ  + å†…å®¹ */
.layout{display:flex}
.sidebar{
  position:fixed;left:0;top:0;height:100dvh;width:280px;background:inherit;
  border-right:1px solid var(--border);transform:translateX(-100%);
  transition:transform .25s ease;z-index:30;display:flex;flex-direction:column
}
body.dark .sidebar{border-right-color:var(--border-dark)}
.sidebar.open{transform:translateX(0)}
.sidebar header{position:sticky;top:0;padding:.7rem .9rem;border:none}
.sidebar .list{overflow:auto;padding:.5rem}
.conv-item{
  padding:.6rem .7rem;border-radius:10px;margin:.25rem 0;cursor:pointer;
  border:1px solid transparent
}
.conv-item:hover{background:color-mix(in oklab,currentColor 4%,transparent)}
.conv-item.active{border-color:var(--border-dark)}
.meta-mini{font-size:.75rem;opacity:.7;margin-top:.2rem}

/* é®ç½©ï¼ˆç§»åŠ¨ç«¯æŠ½å±‰ï¼‰ */
.backdrop{
  position:fixed;inset:0;background:rgba(0,0,0,.2);backdrop-filter:blur(1px);
  opacity:0;pointer-events:none;transition:.2s;z-index:25
}
.backdrop.show{opacity:1;pointer-events:auto}

/* ä¸»å†…å®¹ */
.container{padding:1rem;display:flex;flex-direction:column;gap:.9rem;max-width:980px;margin:0 auto}
.selector, .toolbar, .customize{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.badge{padding:.2rem .5rem;border-radius:7px;border:1px solid var(--border);
  font-size:.78rem;opacity:.9}
body.dark .badge{border-color:var(--border-dark)}
hr{border:none;height:1px;background:var(--border)}
body.dark hr{background:var(--border-dark)}

/* èŠå¤©æ°”æ³¡ */
.chat{display:flex;flex-direction:column;gap:.8rem}
.msg{max-width:var(--bubble-max);padding:.65rem .85rem;border-radius:14px;white-space:pre-wrap;line-height:1.55}
.user{align-self:flex-end;background:var(--user);color:#fff}
.assistant{align-self:flex-start;background:var(--assistant);color:#fff}
.system{align-self:center;background:var(--sys);color:#fff}
.meta{display:flex;justify-content:space-between;gap:.6rem;margin-top:.35rem;font-size:.78rem;opacity:.9}
.model{padding:.15rem .5rem;border-radius:999px;background:var(--chip)}
.branch{margin-top:.5rem;border:1px dashed var(--border);border-radius:10px;padding:.5rem}
body.dark .branch{border-color:var(--border-dark)}
.branch>summary{cursor:pointer;font-size:.85rem;opacity:.9}
.dim{opacity:.6}
footer{padding:1rem 1rem 2rem;color:inherit;opacity:.8;text-align:center}
.small{font-size:.82rem}

/* è‡ªå®šä¹‰é¢œè‰²æ§ä»¶ */
.colorbox{display:flex;gap:.5rem;align-items:center}
.colorbox label{font-size:.82rem;opacity:.85}
.colorbox input[type=color]{width:32px;height:28px;padding:0;border:none;background:transparent}

/* æ¡Œé¢ç«¯å›ºå®šä¾§æ ï¼ˆå¯é€‰ï¼Œå®½å±æ‰å±•ç¤ºï¼‰ */
@media (min-width:1100px){
  .sidebar{transform:translateX(0);position:sticky;top:0;height:100vh}
  .backdrop{display:none}
  .layout{gap:0}
  .container{margin-left:280px}
}
</style>
</head>
<body>
<header>
  <h1><button id="burger" class="icon" aria-label="èœå•">â˜°</button>ğŸ“„ ChatGPT èŠå¤©è®°å½•æŸ¥çœ‹å™¨</h1>
  <div class="controls">
    <input id="file" type="file" accept=".json" />
    <button onclick="pickFile()">å¯¼å…¥</button>
    <button onclick="exportHTML()">å¯¼å‡ºé¡µé¢</button>
    <button onclick="toggleTheme()">å¤œé—´/æ—¥é—´</button>
  </div>
</header>

<div class="layout">
  <!-- ä¾§è¾¹æ  -->
  <aside class="sidebar" id="sidebar">
    <header>
      <div style="display:flex;justify-content:space-between;align-items:center;gap:.5rem">
        <strong>ä¼šè¯åˆ—è¡¨</strong>
        <button id="closeSidebar">å…³é—­</button>
      </div>
      <div class="small dim">ä» conversations.json æˆ–å•ä¼šè¯å¯¼å…¥åæ˜¾ç¤º</div>
    </header>
    <div class="list" id="convListSide"></div>
  </aside>
  <div class="backdrop" id="backdrop"></div>

  <!-- ä¸»å†…å®¹ -->
  <main class="container">
    <div class="selector" id="convSelector" style="display:none">
      <span class="badge">å½“å‰ä¼šè¯ï¼š</span>
      <select id="convListTop" onchange="selectConversation(this.value)"></select>
      <span class="badge" id="convMeta" title="åˆ›å»ºæ—¶é—´ / æ¶ˆæ¯æ•°"></span>
    </div>

    <div class="toolbar" id="filters" style="display:none">
      <span class="badge">åªçœ‹æœ€è¿‘</span>
      <input type="number" id="lastN" min="1" step="1" value="200" style="width:6rem" />
      <span class="badge">æ¡</span>
      <button onclick="applyN()">åº”ç”¨</button>
      <span class="badge">æŒ‰æ¨¡å‹è¿‡æ»¤ï¼š</span>
      <select id="modelFilter" onchange="applyModelFilter()">
        <option value="">å…¨éƒ¨</option>
      </select>
    </div>

    <!-- è‡ªå®šä¹‰åŒºï¼šé¢œè‰² & å®½åº¦ -->
    <div class="customize" id="customizeBar" style="display:none">
      <span class="badge">å¤–è§‚ï¼š</span>
      <div class="colorbox">
        <label>ç”¨æˆ·</label><input type="color" id="cUser">
        <label>åŠ©æ‰‹</label><input type="color" id="cAssistant">
        <label>ç³»ç»Ÿ</label><input type="color" id="cSystem">
      </div>
      <span class="badge">æ°”æ³¡å®½åº¦ï¼š</span>
      <input type="range" id="bubbleWidth" min="60" max="100" value="86" oninput="setBubbleWidth(this.value)">
      <span id="bubbleVal" class="small dim">86%</span>
      <button onclick="resetTheme()">æ¢å¤é»˜è®¤</button>
    </div>

    <div id="chat" class="chat">
      <p class="dim" style="text-align:center">å¯¼å…¥ ChatGPT å®˜æ–¹å¯¼å‡ºçš„ä¼šè¯ JSONï¼ˆå•ä¸ªä¼šè¯æˆ– conversations.jsonï¼‰ã€‚</p>
    </div>
    <footer class="small">ç¦»çº¿è¿è¡Œï½œè§£æ mapping æ ‘ï¼Œä¸»è·¯å¾„å‘ˆç°ï¼Œåˆ†æ”¯æŠ˜å ï½œé¢œè‰²ä¸å®½åº¦åå¥½ä¼šä¿å­˜åˆ°æœ¬åœ°</footer>
  </main>
</div>

<script>
// ============ ä¸»é¢˜ + åå¥½ ============
let dark = false;
const PREF_KEY = 'chatviewer_prefs_v2';
const prefs = loadPrefs();

applyPrefs();

function toggleTheme(){ 
  dark=!dark; 
  document.body.classList.toggle('dark', dark); 
  prefs.dark = dark; savePrefs(); 
}

function loadPrefs(){
  try{ return JSON.parse(localStorage.getItem(PREF_KEY)) || {}; }catch{ return {}; }
}
function savePrefs(){ localStorage.setItem(PREF_KEY, JSON.stringify(prefs)); }
function applyPrefs(){
  dark = !!prefs.dark; document.body.classList.toggle('dark', dark);
  if (prefs.colors){
    if (prefs.colors.user) setCSS('--user', prefs.colors.user);
    if (prefs.colors.assistant) setCSS('--assistant', prefs.colors.assistant);
    if (prefs.colors.sys) setCSS('--sys', prefs.colors.sys);
  }
  if (prefs.bubble){ setCSS('--bubble-max', prefs.bubble+'%'); }
  // åˆå§‹åŒ–æ§ä»¶å€¼
  setTimeout(()=>{
    if (prefs.colors){
      if (prefs.colors.user) document.getElementById('cUser').value = prefs.colors.user;
      if (prefs.colors.assistant) document.getElementById('cAssistant').value = prefs.colors.assistant;
      if (prefs.colors.sys) document.getElementById('cSystem').value = prefs.colors.sys;
    }
    if (prefs.bubble){
      document.getElementById('bubbleWidth').value = Number(prefs.bubble);
      document.getElementById('bubbleVal').textContent = `${prefs.bubble}%`;
    }
  },0);
}
function setCSS(varName, val){ document.documentElement.style.setProperty(varName, val); }
function resetTheme(){
  ['--user','--assistant','--sys'].forEach(v=>document.documentElement.style.removeProperty(v));
  document.getElementById('cUser').value = '#0a84ff';
  document.getElementById('cAssistant').value = '#5e5e66';
  document.getElementById('cSystem').value = '#9b59b6';
  setBubbleWidth(86);
  prefs.colors = { user:'#0a84ff', assistant:'#5e5e66', sys:'#9b59b6' };
  prefs.bubble = 86;
  savePrefs();
}
document.getElementById('cUser').addEventListener('input', e=>{
  setCSS('--user', e.target.value);
  prefs.colors = prefs.colors || {}; prefs.colors.user = e.target.value; savePrefs();
});
document.getElementById('cAssistant').addEventListener('input', e=>{
  setCSS('--assistant', e.target.value);
  prefs.colors = prefs.colors || {}; prefs.colors.assistant = e.target.value; savePrefs();
});
document.getElementById('cSystem').addEventListener('input', e=>{
  setCSS('--sys', e.target.value);
  prefs.colors = prefs.colors || {}; prefs.colors.sys = e.target.value; savePrefs();
});
function setBubbleWidth(val){
  setCSS('--bubble-max', `${val}%`);
  document.getElementById('bubbleVal').textContent = `${val}%`;
  prefs.bubble = Number(val); savePrefs();
}

// ============ æ–‡ä»¶é€‰æ‹© ============
function pickFile(){ document.getElementById('file').click(); }
document.getElementById('file').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const raw = await f.text();
  let data;
  try{ data = JSON.parse(raw); }catch(err){ alert('ä¸æ˜¯æœ‰æ•ˆ JSONï¼šè¯·ä» ChatGPT å®˜æ–¹â€œå¯¼å‡ºæ•°æ®â€é‡Œå–å‡ºçš„ JSON æ–‡ä»¶ã€‚'); return; }
  handleImportedJSON(data);
});

// ============ ä¾§è¾¹æ å¼€åˆ ============
const sidebar = document.getElementById('sidebar');
const backdrop = document.getElementById('backdrop');
document.getElementById('burger').addEventListener('click', ()=> openSidebar(true));
document.getElementById('closeSidebar').addEventListener('click', ()=> openSidebar(false));
backdrop.addEventListener('click', ()=> openSidebar(false));
function openSidebar(show){ 
  if (window.matchMedia('(min-width:1100px)').matches) return; // å®½å±ä¸éœ€è¦åŠ¨ç”»
  sidebar.classList.toggle('open', show); 
  backdrop.classList.toggle('show', show);
}

// ============ è§£æå…¥å£ ============
let conversations = []; // {id,title,created,messages:[{role,content,model,ts,_nodeId,previous:[]}], models:Set}
let currentConvIndex = 0;
let renderCache = { lastN: 200, model: "" };

function handleImportedJSON(data){
  conversations = [];

  if (Array.isArray(data)) {
    data.forEach(obj => { const c = parseConversation(obj); if(c) conversations.push(c); });
  } else if (data && typeof data === 'object') {
    if (data.items && Array.isArray(data.items)) {
      data.items.forEach(obj => { const c = parseConversation(obj); if(c) conversations.push(c); });
    } else {
      const c = parseConversation(data);
      if (c) conversations.push(c);
    }
  }

  if (!conversations.length){
    alert('æ²¡è§£æåˆ°ä¼šè¯ã€‚ç¡®è®¤é€‰æ‹©çš„æ˜¯è§£å‹åçš„ conversations.json æˆ–æŸä¸ª conversations/*.json');
    return;
  }

  // é¡¶éƒ¨ä¸‹æ‹‰
  const selWrap = document.getElementById('convSelector');
  const selTop = document.getElementById('convListTop');
  selTop.innerHTML = '';
  conversations.forEach((c, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = c.title || `(æ— æ ‡é¢˜) ${idx+1}`;
    selTop.appendChild(opt);
  });
  selWrap.style.display = conversations.length>1 ? 'flex' : 'none';

  // ä¾§è¾¹æ åˆ—è¡¨
  buildSidebarList();

  currentConvIndex = 0;
  selTop.value = '0';
  updateConvMeta();
  buildModelFilter();
  document.getElementById('filters').style.display = 'flex';
  document.getElementById('customizeBar').style.display = 'flex';
  render();
}

function buildSidebarList(){
  const list = document.getElementById('convListSide');
  list.innerHTML = '';
  conversations.forEach((c, idx)=>{
    const item = document.createElement('div');
    item.className = 'conv-item'+(idx===currentConvIndex?' active':'');
    item.innerHTML = `<div>${escapeHTML(c.title||`(æ— æ ‡é¢˜) ${idx+1}`)}</div>
      <div class="meta-mini">æ¶ˆæ¯ ${c.messages.length}${c.created?` Â· ${new Date(c.created*1000).toLocaleDateString()}`:''}</div>`;
    item.onclick = ()=>{
      currentConvIndex = idx;
      selectConversation(String(idx));
      openSidebar(false);
      [...list.children].forEach(el=>el.classList.remove('active'));
      item.classList.add('active');
    };
    list.appendChild(item);
  });
}

function selectConversation(idxStr){
  currentConvIndex = Number(idxStr)||0;
  renderCache = { lastN: 200, model: "" };
  document.getElementById('lastN').value = 200;
  document.getElementById('modelFilter').value = "";
  updateConvMeta();
  buildModelFilter();
  buildSidebarList();
  render();
}

function updateConvMeta(){
  const c = conversations[currentConvIndex];
  const meta = document.getElementById('convMeta');
  const created = c.created ? new Date(c.created*1000).toLocaleString() : 'â€”';
  meta.textContent = `åˆ›å»ºï¼š${created}ï½œæ¶ˆæ¯æ•°ï¼š${c.messages.length}`;
}

// ============ è§£æ mapping ============
function parseConversation(obj){
  const title = obj.title || obj.gist || obj.name || '';
  const created = obj.create_time || obj.update_time || obj.created || 0;
  const mapping = obj.mapping;
  const current = obj.current_node;

  if (!mapping || !current) {
    if (Array.isArray(obj.messages)) {
      const msgs = obj.messages.map(normalizeLinearMessage).filter(Boolean);
      return { id: obj.id || crypto.randomUUID(), title, created, messages: msgs, models: new Set(msgs.map(m=>m.model).filter(Boolean)) };
    }
    return null;
  }

  const pathIds = [];
  let nodeId = current;
  while (nodeId && mapping[nodeId]) {
    pathIds.push(nodeId);
    nodeId = mapping[nodeId].parent || null;
  }
  pathIds.reverse();

  const messages = [];
  const pathSet = new Set(pathIds);
  pathIds.forEach(pid=>{
    const n = mapping[pid];
    const m = normalizeNodeMessage(n);
    if (m) messages.push(m);
  });

  const idToIndex = new Map();
  messages.forEach((m, i)=>{ idToIndex.set(m._nodeId, i); });

  pathIds.forEach(pid=>{
    const node = mapping[pid];
    const children = Array.isArray(node.children) ? node.children : [];
    const branchKids = children.filter(cid => !pathSet.has(cid));
    if (!branchKids.length) return;
    const branchTexts = [];
    branchKids.forEach(bid => { collectBranchTexts(mapping, bid, branchTexts); });
    const at = idToIndex.get(pid);
    if (typeof at === 'number' && branchTexts.length) {
      messages[at].previous = branchTexts.slice(0, 300);
    }
  });

  const msgs = messages.filter(m => m.content && m.content.trim().length);
  return {
    id: obj.id || crypto.randomUUID(),
    title, created,
    messages: msgs,
    models: new Set(msgs.map(m=>m.model).filter(Boolean))
  };
}

function normalizeLinearMessage(m){
  const role = m.role || (m.author?.role) || "assistant";
  const parts = Array.isArray(m.content?.parts) ? m.content.parts.join("\n") : (m.content?.text || m.content || "");
  const content = typeof parts === 'string' ? parts : JSON.stringify(parts);
  const model = m.model || m.metadata?.model_slug || m.metadata?.model || "";
  const ts = m.create_time || m.ts || 0;
  return { role, content, model, ts, previous: [] };
}
function normalizeNodeMessage(node){
  const msg = node.message;
  if (!msg || !msg.author) return null;
  const role = msg.author.role || "assistant";
  if (!["user","assistant","system"].includes(role)) return null;

  let text = "";
  if (Array.isArray(msg.content?.parts)) text = msg.content.parts.join("\n");
  else if (typeof msg.content?.text === 'string') text = msg.content.text;
  else if (typeof msg.content === 'string') text = msg.content;

  const model = msg.metadata?.model_slug || msg.metadata?.model || msg.model_slug || msg.model || "";
  const ts = msg.create_time || node.create_time || 0;
  return { role, content: text || "", model, ts, previous: [], _nodeId: node.id };
}
function collectBranchTexts(mapping, startId, out){
  const stack = [startId];
  while (stack.length){
    const id = stack.pop();
    const n = mapping[id];
    if (!n) continue;
    const m = normalizeNodeMessage(n);
    if (m && m.content) out.push(`[${m.role}] ${m.content}`);
    const kids = Array.isArray(n.children) ? n.children : [];
    for (let i=kids.length-1;i>=0;i--) stack.push(kids[i]);
  }
}

// ============ æ¸²æŸ“ =============
function render(){
  const chat = document.getElementById('chat');
  chat.innerHTML = '';
  const c = conversations[currentConvIndex];
  if (!c){ chat.textContent="æ— ä¼šè¯"; return; }

  let arr = c.messages.slice();
  if (renderCache.model){
    arr = arr.filter(m => (m.model||"").includes(renderCache.model));
  }
  if (renderCache.lastN && arr.length > renderCache.lastN){
    arr = arr.slice(-renderCache.lastN);
  }

  if (!arr.length){
    const p = document.createElement('p');
    p.className = 'dim';
    p.textContent = 'ç­›é€‰åæ²¡æœ‰æ¶ˆæ¯ã€‚è°ƒæ•´â€œåªçœ‹æœ€è¿‘Næ¡â€æˆ–æ¨¡å‹è¿‡æ»¤è¯•è¯•ã€‚';
    chat.appendChild(p);
    return;
  }

  arr.forEach(m=>{
    const div = document.createElement('div');
    div.className = `msg ${clsByRole(m.role)}`;
    div.innerText = m.content || '';
    chat.appendChild(div);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const ts = m.ts ? new Date(m.ts*1000).toLocaleString() : '';
    const model = m.model || '';
    meta.innerHTML = `<span class="dim">${ts}</span><span class="model">${escapeHTML(model||'â€”')}</span>`;
    chat.appendChild(meta);

    if (m.previous && m.previous.length){
      const details = document.createElement('details');
      details.className = 'branch';
      const summary = document.createElement('summary');
      summary.textContent = `å›æº¯/åˆ†æ”¯ï¼ˆ${m.previous.length} æ¡ï¼‰`;
      details.appendChild(summary);
      const wrap = document.createElement('div');
      wrap.style.marginTop = '.5rem';
      m.previous.forEach(t=>{
        const p = document.createElement('div');
        p.style.margin = '.25rem 0';
        p.textContent = t;
        wrap.appendChild(p);
      });
      details.appendChild(wrap);
      chat.appendChild(details);
    }
  });
}

function clsByRole(role){
  if (role === 'user') return 'user';
  if (role === 'system') return 'system';
  return 'assistant';
}

function applyN(){
  const n = Number(document.getElementById('lastN').value)||0;
  renderCache.lastN = n>0 ? n : 200;
  render();
}
function buildModelFilter(){
  const sel = document.getElementById('modelFilter');
  sel.innerHTML = `<option value="">å…¨éƒ¨</option>`;
  const c = conversations[currentConvIndex];
  const arr = Array.from(c.models || []).sort();
  arr.forEach(m=>{
    const op = document.createElement('option');
    op.value = m; op.textContent = m;
    sel.appendChild(op);
  });
}
function applyModelFilter(){
  renderCache.model = document.getElementById('modelFilter').value || "";
  render();
}

// ============ å¯¼å‡ºï¼ˆåˆ°æ–‡ä»¶App çš„â€œä¸‹è½½â€ï¼‰ ============
function exportHTML(){
  // æ‰€è§å³æ‰€å¾—å¯¼å‡ºï¼ˆåŒ…å«å½“å‰é¢œè‰²ä¸å®½åº¦è®¾ç½®ï¼‰
  const blob = new Blob([document.documentElement.outerHTML], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'chat_export.html'; a.click();
  URL.revokeObjectURL(url);
}

// ============ å°å·¥å…· ============
function escapeHTML(s){ return (s||'').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;' }[m])); }

// åˆæ¬¡æ˜¾ç¤ºè‡ªå®šä¹‰é¢æ¿çŠ¶æ€ï¼ˆå’Œè¿‡æ»¤æ¡ï¼‰
document.getElementById('filters').style.display = 'none';
document.getElementById('customizeBar').style.display = 'none';
</script>
</body>
</html>
