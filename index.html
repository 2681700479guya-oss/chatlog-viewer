<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ChatGPT èŠå¤©è®°å½•æŸ¥çœ‹å™¨</title>
<style>
:root{
  --bg-light:#f6f6f7; --bg-dark:#1b1b1f;
  --text-light:#0f1115; --text-dark:#e7e7ea;
  --user:#0a84ff; --assistant:#5e5e66; --sys:#9b59b6;
  --chip:#d0d5dd22; --border:#00000014; --border-dark:#ffffff22;
}
*{box-sizing:border-box}
body{margin:0;font-family:-apple-system,BlinkMacSystemFont,"Helvetica Neue",Arial,sans-serif;background:var(--bg-light);color:var(--text-light);transition:.25s}
body.dark{background:var(--bg-dark);color:var(--text-dark)}
header{position:sticky;top:0;backdrop-filter:saturate(180%) blur(8px);
  background:color-mix(in oklab,currentColor 5%,transparent);
  display:flex;gap:.6rem;align-items:center;justify-content:space-between;
  padding:.6rem .9rem;border-bottom:1px solid var(--border)}
body.dark header{border-bottom-color:var(--border-dark)}
h1{font-size:1rem;margin:0;font-weight:600}
.controls{display:flex;gap:.4rem;flex-wrap:wrap;align-items:center;justify-content:flex-end}
button,select,input[type="number"]{
  padding:.45rem .7rem;border-radius:9px;border:1px solid var(--border);
  background:#fff;color:#111;cursor:pointer;font-size:.9rem
}
body.dark button,body.dark select,body.dark input[type="number"]{
  background:#2a2a31;color:var(--text-dark);border-color:var(--border-dark)
}
button:active{transform:scale(.98)}
input[type=file]{display:none}

.toolbar{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
.badge{padding:.2rem .5rem;border-radius:7px;border:1px solid var(--border);
  font-size:.78rem;opacity:.9}
body.dark .badge{border-color:var(--border-dark)}
.container{padding:1rem;display:flex;flex-direction:column;gap:.9rem}
.selector{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
hr{border:none;height:1px;background:var(--border)}
body.dark hr{background:var(--border-dark)}

.chat{display:flex;flex-direction:column;gap:.8rem}
.msg{max-width:86%;padding:.65rem .85rem;border-radius:14px;white-space:pre-wrap;line-height:1.55}
.user{align-self:flex-end;background:var(--user);color:#fff}
.assistant{align-self:flex-start;background:var(--assistant);color:#fff}
.system{align-self:center;background:var(--sys);color:#fff}
.meta{display:flex;justify-content:space-between;gap:.6rem;margin-top:.35rem;font-size:.78rem;opacity:.9}
.model{padding:.15rem .5rem;border-radius:999px;background:var(--chip)}
.branch{
  margin-top:.5rem;border:1px dashed var(--border);border-radius:10px;padding:.5rem
}
body.dark .branch{border-color:var(--border-dark)}
.branch>summary{cursor:pointer;font-size:.85rem;opacity:.9}
.dim{opacity:.6}
footer{padding:1rem 1rem 2rem;color:inherit;opacity:.8;text-align:center}
.small{font-size:.82rem}
</style>
</head>
<body>
<header>
  <h1>ğŸ“„ ChatGPT èŠå¤©è®°å½•æŸ¥çœ‹å™¨</h1>
  <div class="controls">
    <input id="file" type="file" accept=".json" />
    <button onclick="pickFile()">å¯¼å…¥</button>
    <button onclick="exportHTML()">å¯¼å‡ºé¡µé¢</button>
    <button onclick="toggleTheme()">å¤œé—´/æ—¥é—´</button>
  </div>
</header>

<div class="container">
  <div class="selector" id="convSelector" style="display:none">
    <span class="badge">é€‰æ‹©ä¼šè¯ï¼š</span>
    <select id="convList" onchange="selectConversation(this.value)"></select>
    <span class="badge" id="convMeta" title="åˆ›å»ºæ—¶é—´ / æ¶ˆæ¯æ•°"></span>
  </div>

  <div class="toolbar" id="filters" style="display:none">
    <span class="badge">åªçœ‹æœ€è¿‘</span>
    <input type="number" id="lastN" min="1" step="1" value="200" style="width:6rem" />
    <span class="badge">æ¡</span>
    <button onclick="applyN()">åº”ç”¨</button>
    <span class="badge">æŒ‰æ¨¡å‹è¿‡æ»¤ï¼š</span>
    <select id="modelFilter" onchange="applyModelFilter()">
      <option value="">å…¨éƒ¨</option>
    </select>
  </div>

  <div id="chat" class="chat">
    <p class="dim" style="text-align:center">å¯¼å…¥ ChatGPT å®˜æ–¹å¯¼å‡ºçš„ä¼šè¯ JSONï¼ˆå•ä¸ªä¼šè¯æˆ– conversations.jsonï¼‰ã€‚</p>
  </div>
</div>

<footer class="small">æœ¬å·¥å…·ç¦»çº¿è¿è¡Œï¼Œè§£æ ChatGPT å®˜æ–¹å¯¼å‡ºï¼ˆmapping æ ‘ï¼‰ï¼Œé»˜è®¤å±•ç¤ºâ€œä¸»è·¯å¾„â€å¯¹è¯ï¼Œåˆ†æ”¯ä½œä¸ºâ€œå›æº¯â€å¯æŠ˜å æŸ¥çœ‹ã€‚</footer>

<script>
// ============ ä¸»é¢˜ ============
let dark = false;
function toggleTheme(){ dark=!dark; document.body.classList.toggle('dark', dark); }

// ============ æ–‡ä»¶é€‰æ‹© ============
function pickFile(){ document.getElementById('file').click(); }
document.getElementById('file').addEventListener('change', async (e)=>{
  const f = e.target.files?.[0]; if(!f) return;
  const raw = await f.text();
  let data;
  try{ data = JSON.parse(raw); }catch(err){ alert('ä¸æ˜¯æœ‰æ•ˆ JSONï¼šè¯·ä» ChatGPT å®˜æ–¹â€œå¯¼å‡ºæ•°æ®â€é‡Œå–å‡ºçš„ JSON æ–‡ä»¶ã€‚'); return; }
  handleImportedJSON(data);
});

// ============ è§£æå…¥å£ ============
let conversations = []; // {id,title,created,messages:[{role,content,model,ts}], models:Set}
let currentConvIndex = 0;
let renderCache = { lastN: 200, model: "" };

function handleImportedJSON(data){
  // å¯èƒ½æ˜¯ï¼š1) å•ä¸ªä¼šè¯å¯¹è±¡ï¼ˆå« mappingï¼‰ 2) conversations.json ä¸­çš„æ•°ç»„/å¯¹è±¡åˆ—è¡¨
  conversations = [];

  if (Array.isArray(data)) {
    // conversations.jsonï¼ˆæ•°ç»„ï¼‰
    data.forEach(obj => { const c = parseConversation(obj); if(c) conversations.push(c); });
  } else if (data && typeof data === 'object') {
    if (data.items && Array.isArray(data.items)) {
      // æŸäº›å¯¼å‡ºæ˜¯ { items:[conv, conv,...] }
      data.items.forEach(obj => { const c = parseConversation(obj); if(c) conversations.push(c); });
    } else {
      // å•ä¼šè¯
      const c = parseConversation(data);
      if (c) conversations.push(c);
    }
  }

  if (!conversations.length){
    alert('æ²¡è§£æåˆ°ä¼šè¯ã€‚è¯·ç¡®è®¤ï¼š\n- é€‰æ‹©çš„æ˜¯å•ä¸ªä¼šè¯ JSON æˆ– conversations.json\n- å¦‚æœä½ æ‹¿åˆ°çš„æ˜¯ ZIPï¼Œè¯·å…ˆåœ¨â€œæ–‡ä»¶â€Appé‡Œè§£å‹ï¼Œå†é€‰ JSON');
    return;
  }

  // å¡«ä¼šè¯ä¸‹æ‹‰
  const selWrap = document.getElementById('convSelector');
  const sel = document.getElementById('convList');
  sel.innerHTML = '';
  conversations.forEach((c, idx)=>{
    const opt = document.createElement('option');
    opt.value = String(idx);
    opt.textContent = c.title || `(æ— æ ‡é¢˜) ${idx+1}`;
    sel.appendChild(opt);
  });
  selWrap.style.display = conversations.length>1 ? 'flex' : 'none';

  currentConvIndex = 0;
  sel.value = '0';
  updateConvMeta();
  buildModelFilter();
  render();
}

function selectConversation(idxStr){
  currentConvIndex = Number(idxStr)||0;
  renderCache = { lastN: 200, model: "" };
  document.getElementById('lastN').value = 200;
  document.getElementById('modelFilter').value = "";
  updateConvMeta();
  buildModelFilter();
  render();
}

function updateConvMeta(){
  const c = conversations[currentConvIndex];
  const meta = document.getElementById('convMeta');
  const created = c.created ? new Date(c.created*1000).toLocaleString() : 'â€”';
  meta.textContent = `åˆ›å»ºï¼š${created}ï½œæ¶ˆæ¯æ•°ï¼š${c.messages.length}`;
}

// ============ è§£æå•ä¸ªä¼šè¯ï¼ˆmapping â†’ ä¸»è·¯å¾„ + åˆ†æ”¯ï¼‰ ============
function parseConversation(obj){
  // ç²—å…¼å®¹ä¸åŒå¯¼å‡ºç‰ˆæœ¬
  const title = obj.title || obj.gist || obj.name || '';
  const created = obj.create_time || obj.update_time || obj.created || 0;
  const mapping = obj.mapping;
  const current = obj.current_node;

  if (!mapping || !current) {
    // æŸäº›æ—©æœŸå¯¼å‡ºå¯èƒ½æœ‰ linear "messages"
    if (Array.isArray(obj.messages)) {
      const msgs = obj.messages.map(normalizeLinearMessage).filter(Boolean);
      return { id: obj.id || crypto.randomUUID(), title, created, messages: msgs, models: new Set(msgs.map(m=>m.model).filter(Boolean)) };
    }
    return null;
  }

  // 1) æ²¿ current_node å›æº¯åˆ°æ ¹ï¼Œå¾—åˆ°â€œä¸»è·¯å¾„â€
  const pathIds = [];
  let nodeId = current;
  while (nodeId && mapping[nodeId]) {
    pathIds.push(nodeId);
    nodeId = mapping[nodeId].parent || null;
  }
  pathIds.reverse(); // æ ¹â†’current

  // 2) ä¸»è·¯å¾„æ¶ˆæ¯æå–
  const messages = [];
  const pathSet = new Set(pathIds);

  pathIds.forEach(pid=>{
    const n = mapping[pid];
    const m = normalizeNodeMessage(n);
    if (m) messages.push(m);
  });

  // 3) åˆ†æ”¯ï¼šæ¯ä¸ªä¸»è·¯å¾„èŠ‚ç‚¹çš„ children ä¸­ï¼Œå‡¡æ˜¯ä¸åœ¨ä¸»è·¯å¾„çš„å­æ ‘ï¼Œä½œä¸ºè¯¥èŠ‚ç‚¹çš„â€œå›æº¯/æŠ˜å â€æ”¶é›†
  // æˆ‘ä»¬æŠŠè¿™äº›åˆ†æ”¯çš„çº¯æ–‡æœ¬æ±‡æ€»åˆ°ç´§è·Ÿçš„è¯¥èŠ‚ç‚¹ message.previous[]ï¼Œè®© UI å¯æŠ˜å æŸ¥çœ‹
  const idToIndex = new Map();
  messages.forEach((m, i)=>{ idToIndex.set(m._nodeId, i); });

  pathIds.forEach(pid=>{
    const node = mapping[pid];
    const children = Array.isArray(node.children) ? node.children : [];
    const branchKids = children.filter(cid => !pathSet.has(cid));
    if (!branchKids.length) return;
    const branchTexts = [];
    branchKids.forEach(bid => {
      collectBranchTexts(mapping, bid, branchTexts);
    });
    const at = idToIndex.get(pid);
    if (typeof at === 'number' && branchTexts.length) {
      messages[at].previous = branchTexts.slice(0, 200); // é˜²ç‚¸
    }
  });

  // å»é™¤ç³»ç»Ÿæ— å†…å®¹çš„èŠ‚ç‚¹
  const msgs = messages.filter(m => m.content && m.content.trim().length);

  return {
    id: obj.id || crypto.randomUUID(),
    title, created,
    messages: msgs,
    models: new Set(msgs.map(m=>m.model).filter(Boolean))
  };
}

function normalizeLinearMessage(m){
  // çº¿æ€§æ•°ç»„å…œåº•
  const role = m.role || (m.author?.role) || "assistant";
  const parts = Array.isArray(m.content?.parts) ? m.content.parts.join("\n") : (m.content?.text || m.content || "");
  const content = typeof parts === 'string' ? parts : JSON.stringify(parts);
  const model = m.model || m.metadata?.model_slug || m.metadata?.model || "";
  const ts = m.create_time || m.ts || 0;
  return { role, content, model, ts, previous: [] };
}

function normalizeNodeMessage(node){
  const msg = node.message;
  if (!msg || !msg.author) return null;
  const role = msg.author.role || "assistant";
  if (!["user","assistant","system"].includes(role)) return null;

  let text = "";
  if (Array.isArray(msg.content?.parts)) text = msg.content.parts.join("\n");
  else if (typeof msg.content?.text === 'string') text = msg.content.text;
  else if (typeof msg.content === 'string') text = msg.content;

  const model = msg.metadata?.model_slug || msg.metadata?.model || msg.model_slug || msg.model || "";
  const ts = msg.create_time || node.create_time || 0;
  return { role, content: text || "", model, ts, previous: [], _nodeId: node.id };
}

function collectBranchTexts(mapping, startId, out){
  const stack = [startId];
  while (stack.length){
    const id = stack.pop();
    const n = mapping[id];
    if (!n) continue;
    const m = normalizeNodeMessage(n);
    if (m && m.content) out.push(`[${m.role}] ${m.content}`);
    const kids = Array.isArray(n.children) ? n.children : [];
    // æ·±åº¦ä¼˜å…ˆ
    for (let i=kids.length-1;i>=0;i--) stack.push(kids[i]);
  }
}

// ============ æ¸²æŸ“ ============
function render(){
  const chat = document.getElementById('chat');
  chat.innerHTML = '';
  const c = conversations[currentConvIndex];
  if (!c){ chat.textContent="æ— ä¼šè¯"; return; }

  // è¿‡æ»¤ï¼šæ¨¡å‹ + åªçœ‹æœ€è¿‘ N æ¡
  let arr = c.messages.slice();
  if (renderCache.model){
    arr = arr.filter(m => (m.model||"").includes(renderCache.model));
  }
  if (renderCache.lastN && arr.length > renderCache.lastN){
    arr = arr.slice(-renderCache.lastN);
  }

  // æ˜¾ç¤ºè¿‡æ»¤å·¥å…·æ¡
  document.getElementById('filters').style.display = 'flex';

  if (!arr.length){
    const p = document.createElement('p');
    p.className = 'dim';
    p.textContent = 'ç­›é€‰åæ²¡æœ‰æ¶ˆæ¯ã€‚è°ƒæ•´â€œåªçœ‹æœ€è¿‘Næ¡â€æˆ–æ¨¡å‹è¿‡æ»¤è¯•è¯•ã€‚';
    chat.appendChild(p);
    return;
  }

  arr.forEach(m=>{
    const div = document.createElement('div');
    div.className = `msg ${clsByRole(m.role)}`;
    div.innerText = m.content || '';
    chat.appendChild(div);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const ts = m.ts ? new Date(m.ts*1000).toLocaleString() : '';
    const model = m.model || '';
    meta.innerHTML = `<span class="dim">${ts}</span><span class="model">${model||'â€”'}</span>`;
    chat.appendChild(meta);

    if (m.previous && m.previous.length){
      const details = document.createElement('details');
      details.className = 'branch';
      const summary = document.createElement('summary');
      summary.textContent = `å›æº¯/åˆ†æ”¯ï¼ˆ${m.previous.length} æ¡ï¼‰`;
      details.appendChild(summary);
      const wrap = document.createElement('div');
      wrap.style.marginTop = '.5rem';
      m.previous.forEach(t=>{
        const p = document.createElement('div');
        p.style.margin = '.25rem 0';
        p.textContent = t;
        wrap.appendChild(p);
      });
      details.appendChild(wrap);
      chat.appendChild(details);
    }
  });
}

function clsByRole(role){
  if (role === 'user') return 'user';
  if (role === 'system') return 'system';
  return 'assistant';
}

// è¿‡æ»¤å·¥å…·
function applyN(){
  const n = Number(document.getElementById('lastN').value)||0;
  renderCache.lastN = n>0 ? n : 200;
  render();
}
function buildModelFilter(){
  const sel = document.getElementById('modelFilter');
  sel.innerHTML = `<option value="">å…¨éƒ¨</option>`;
  const c = conversations[currentConvIndex];
  const arr = Array.from(c.models || []).sort();
  arr.forEach(m=>{
    const op = document.createElement('option');
    op.value = m; op.textContent = m;
    sel.appendChild(op);
  });
}
function applyModelFilter(){
  renderCache.model = document.getElementById('modelFilter').value || "";
  render();
}

// å¯¼å‡ºå½“å‰é¡µé¢ï¼ˆæ‰€è§å³æ‰€å¾—ï¼Œå«æ ·å¼ï¼‰
function exportHTML(){
  const blob = new Blob([document.documentElement.outerHTML], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'chat_export.html'; a.click();
  URL.revokeObjectURL(url);
}
</script>
</body>
</html>
